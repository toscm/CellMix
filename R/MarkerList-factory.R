# Factory method for MarkerList objects
# 
# Author: Renaud Gaujoux
# Created: 30 Nov 2012
###############################################################################

#' @include MarkerList-class.R
NULL

############
# FACTORY
############
#' This method acts as a Constructor-Copy that returns the input MarkerList 
#' object unchanged if no other argument are passed, or creates a new 
#' MarkerList object based on \code{object}, using the arguments in \code{...} 
#' to initialise the slots.
#' 
#' @examples
#' ## create a MarkerList from another MarkerList
#' m <- rMarkerList(3, 4, names=TRUE)
#' m
#' MarkerList(m, setName=mkScalar("Another list of markers"))
#' 
setMethod('MarkerList', 'MarkerList', 
        function(object, ...){
            if( nargs() == 1L ) object 
            else new('MarkerList', object, ...)
        }
)
#' Creates a \code{MarkerList} object as per \code{new('MarkerList', ...)} or
#' from a file (see section \emph{Loading from files}).
#' 
#' @section Loading from files:
#' 
#' Loading marker lists directly from files can be performed by providing filename to argument \code{file}.
#' Currently this functionality is only implemented for plain text files that contain one marker 
#' feature description per line: marker names (e.g., ENTREZID), marker set (e.g., cell type name) and optionally 
#' some numeric value (e.g. specificity score).
#' 
#' In this case all arguments in \code{...} are passed to \code{\link{read.table}}, 
#' and should be set so that the loaded data.frame conforms with one of the following formats:
#' \describe{
#' \item{at least one column and row names:}{ the row names are used as marker names,
#' column 1 as marker set.
#' Note that tables with automatic rownames generated by \code{read.table} (i.e. 1,2,3, etc..) 
#' are not considered as proper rownames.}
#' \item{two columns and no row names:}{column 1 is used for marker names, 
#' column 2 for the marker set names.}
#' \item{single column and no (or automatic) rownames:}{column is used for marker set names, 
#' the markers are taken to be integers.}
#' }
#' Optionally, in all cases, the next numeric column after the one used for marker set names 
#' is used for associated numeric values.
#' 
#' @param file filename of a file that contains marker data.
#' Conneciton objects are also supported.
#' 
#' @examples
#' 
#' txtdesc <- function(x) textConnection(paste(x, collapse="\n"))
#' 
#' # two columns
#' ml <- MarkerList(file=txtdesc(c("m1 a", "m2 b", "m3 a")))
#' summary(ml)
#' 
#' # single column with row.names
#' ml2 <- MarkerList(file=txtdesc(c("m1 a", "m2 b", "m3 a")), row.names=1L)
#' identical(ml, ml2)
#' 
#' # three columns with values
#' mlv <- MarkerList(file=txtdesc(c("m1 a 1.4", "m2 b 1.5", "m3 a 2.6")))
#' summary(mlv)
#' print(mlv)
#' 
#' # skip an extra column
#' mlv <- MarkerList(file=txtdesc(c("m1 a 1.4", "m2 b 1.5", "m3 a 2.6")))
#' summary(mlv)
#' print(mlv)
#' 
#' # single column: index MarkerList
#' ml <- MarkerList(file=txtdesc(c("a", "b", "a")))
#' summary(ml)
#' 
#' 
setMethod('MarkerList', 'missing', 
        function(object, ..., file=NULL) {
            if( is.null(file) ) new('MarkerList', ...)
            else{
                tab <- read.table(file=file, ...)
                ival <- 0L
                m <- NULL
                if( !nrow(tab) ){
                    # do nothing: empty MarkerList
                    m <- MarkerList()
                }else if( !is.null(rownames(tab)) && !identical(rownames(tab), as.character(1:nrow(tab))) ){
                    ival <- 2L
                    m <- setNames(tab[, 1L], rownames(tab))
                }else if( ncol(tab) >= 2L ){
                    ival <- 3L
                    m <- setNames(tab[, 2L], tab[, 1L])
                } else if( ncol(tab) == 1L ){
                    m <- MarkerList(tab[, 1L])
                }else{
                    stop("Could not load marker list from file '", file, "': table format not supported")
                }
                
                # build MarkerList object, adding values if possible
                if( !isMarkerList(m) && length(m) ){
                    m <- factor(m)
                    if( ival && ncol(tab) >= ival ){
                        wnum <- which(sapply(tab, is, 'numeric'))
                        if( length(wnum) ){ # use values
                            val <- tab[, wnum[1L]] # values
                            # build marker list
                            m <- MarkerList(setNames(val, names(m)), names=m)
                        }else{ # no values
                            m <- MarkerList(m)
                        }
                    }else{
                        m <- MarkerList(m)
                    }
                }
                m
            }
        }
)
#' Default method that tries to retrieve marker data from the input object
#' using the function \code{\link{getMarkers}}.
#'    
setMethod('MarkerList', 'ANY', 
        function(object, ...){
            MarkerList(getMarkers(object), ...)
        }
)
#' Creates a \code{MarkerList} object treating the input vector as a factor, 
#' except if the input is a numeric vector of scores.
#' See \code{\link{MarkerList,factor-method}}.
#' 
#' If \code{object} is numeric, one also needs to supply a factor that defines
#' the cell types.
#' Markers ids are taken from the names \code{object}, or, if missing, from 
#' the names of \code{types}. 
#'   
setMethod('MarkerList', 'vector', 
        function(object, ..., names=NULL){
            
            types <- names
            names <- match.fun('names')
            if( hasValues(object) ){
                if( is.null(nm <- names(object)) ){
                    if( is.null(nm <- names(types)) )
                        stop("Could not infer marker type names: arguments `object` or `types` have no names.")
                }
                if( !is.factor(types) )	types <- factor(types, levels=unique(types))
                # split values by type
                l <- split(object, types)
                # create object
                MarkerList(l, ...)
            }else{
                # use provided types if possible
#			if( !is.null(types) ) object <- setNames(object, types)
                MarkerList(as.factor(object), ...)
            }
        }
)

#' Creates a MarkerList object using the -- normally -- duplicated names of 
#' the input vector as types, and the values as marker indexes.
#' See \code{\link{MarkerList,factor-method}}.
#' 
#' @examples
#' 
#' ## create a MarkerList from an integer vector
#' # names are required
#' try( MarkerList( 1:15 ) )
#' # repeated names define marker sets
#' MarkerList( setNames(1:12, rep(letters[1:3], 4)) ) 
#' 
setMethod('MarkerList', 'integer', 
        function(object, ...){
            if( is.null(names(object)) )
                stop("MarkerList - Invalid integer vector: must have -- duplicated -- names.")		
            l <- split(setNames(object, NULL), factor(names(object)))
            MarkerList(l, ...)
        }
)
#' Either loads a marker list from the internal registry (see \code{\link{cellMarkers}}), 
#' or use the names of \code{object} for defining the sets and the values (strings) 
#' as marker identifiers.
#' 
#' If no names are present, then it uses the character vector as a factor, whose levels 
#' are the sets, and creates an index marker list with 
#' \code{MarkerList,factor-method}.
#' 
#' @param names factor or character vector that defines the types associated to each marker 
#' in \code{object}. 
#' 
#' @examples 
#'
#' ## create a MarkerList from a character vector
#' # no names: repeated values define the sets
#' v <- sample(letters[1:3], 15, replace=TRUE)
#' MarkerList(v)
#' # with names: repeated names define the sets
#' m <- str_c('M', 1:15)
#' MarkerList( setNames(m, v) )
#' 
setMethod('MarkerList', 'character', 
        function(object, ..., names=NULL){
            types <- names
            names <- match.fun('names')
            if( length(object) == 1L && is.null(names(object)) ) cellMarkers(object, ...)
            else{
                if( !is.null(types) ) object <- setNames(object, types)
                if( !is.null(names(object)) )
                    MarkerList(factor(setNames(names(object), object)), ...)
                else callNextMethod()
            }
        }
)
#' Create a MarkerList object by splitting the input factor into a list of its
#' different levels.
#' 
#' If \code{object} has names they are used as marker identifiers, otherwise an
#' index marker list is created.
#' 
#' @examples 
#' 
#' ## create a MarkerList from a factor
#' f <- factor(sample(letters[1:3], 15, replace=TRUE))
#' MarkerList(f)
#' MarkerList( addNames(f, 'M') )
#' 
setMethod('MarkerList', 'factor', 
        function(object, ...){
            
            # split the names according to the factor's levels
            mnames <- if( !is.null(names(object)) ) names(object) else seq_along(object)
            l <- split(mnames, object)			
            # create object from list
            MarkerList(l, ...)
            
        }
)
#' Convert a standard list into a MarkerList object.
#' 
#' The list should contain no duplicated marker identifiers (either as strings or 
#' integer indexes).
#' 
#' @param unlist logical that indicates if the result should be a vector representation
#' of the marker list. In this case auxiliary numeric values are dropped from the list.
#' @param quiet logical that indicates if warnings should be silenced if any.
#' 
#' @examples
#' 
#' ## create an index MarkerList from a standard list
#' m <- list(1:3, 5:10, c(4L,12L)) 
#' MarkerList(m) 
#' 
#' # with mixed integer/numeric, a warning is thrown 
#' m <- list(1:3, 5:10, c(4,12)) 
#' MarkerList(m)
#' 
setMethod('MarkerList', 'list', 
        function(object, ..., unlist=FALSE, quiet = FALSE){
            
            # ensure there are names
            object <- addNames(object, 'Type_')
            
            # return the marker list
            if( unlist ){
                unlist2( dropvalues(object) )
            }else{
                
#			# convert elements to GeneSet or GeneValueSet objects if necessary
#			n <- 0L
#			l <- lapply(seq_along(object), function(i, ...){
#				m <- object[[i]]
#				if( !is.numeric(m) ) res <- GeneValueSet(m, ..., setName=names(object)[i]) 
#				else{
#					res <- GeneValueSet(m, ..., setName=names(object)[i], shift=n)
#					n <<- n + length(geneIds(res))
#				}
#				res
#			}, ...)
                # fix mix of integer and numeric
                cl <- sapply(object, class)
                if( all(c('integer', 'numeric') %in% cl) ){
                    if( !quiet ){
                        warning("MarkerList - Converting mixed integer/numeric elements into integers.")
                    }
                    object <- sapply(object, function(x){
                                as.integer(x)		
                            }, simplify=FALSE)
                }
                as.MarkerList(object, ...)
            }
        }
)


.extractMarkers_signatures <- function(object, values=TRUE, add.names=TRUE){
    
    object <- exprs(object)
    jmax <- max.col(object)
    # get set names
    types <- if( !is.null(colnames(object)) ){
                types <- colnames(object)[jmax]
                factor(types, levels=colnames(object))
            } else {
                types <- (1:ncol(object))[jmax]
                factor(types, levels=1:ncol(object))
            }
    # extract values
    if( values ){
        # add rownames if necessary
        if( is.null(rownames(object)) ){
            if( add.names )
                warning("MarkerList - Rownames were generated (as integers) to be able to attach row maximum values.")
            else
                stop("MarkerList - Cannot attach row maximum values: the input matrix has no rownames.")
            rownames(object) <- 1:nrow(object)
        }
        
        val <- setNames(mapply(function(i, j) object[i,j], 1:nrow(object), jmax), rownames(object))
        split(val, types)
    }else{
        # use rownames or indexes
        m <- if( !is.null(rownames(object)) ) rownames(object) else 1:nrow(object)
        split(m, types)
    }
} 

#' Creates a MarkerList object from a numeric matrix, that is assumed to 
#' have one column per marker set, e.g., a matrix cell type-specific signature.
#' 
#' This method uses a very simple heuristic, which associate each row in a 
#' matrix to the column with the maximum entry (see \code{\link{max.col}}).
#' 
#' For more complex and finer ways of extracting markers from expression 
#' data see \code{\link{extractMarkers}}.
#'
#' The rownames are used as marker identifiers if present. 
#' If not otherwise specified, each marker is associated with its 
#' correspondong row maximum, which is also stored in the 
#' result object.
#' 
#' @param values a logical that indicates if the row maximums should be 
#' embedded into the marker list.
#' @param add.names logical that indicates if names should be added if 
#' necessary (\code{TRUE}).
#' This is used in the case the input matrix has no rownames and the 
#' row maximum values are requested to be attached to the marker list 
#' (\code{values=TRUE}), which throws an error if \code{add.names=FALSE}. 
#'
#' @examples
#' 
#' ## create a MarkerList from a matrix of signatures
#' s <- rmatrix(10,4)
#' m <- MarkerList( s )
#' # the object has values, that can be dropped is necessary
#' m
#' dropvalues(m)
#' # or directly
#' identical(dropvalues(m), MarkerList(s, values=FALSE))
#' 
setMethod('MarkerList', 'matrix', 
        function(object, ..., values=TRUE, add.names=TRUE){
            
            m <- .extractMarkers_signatures(object, values=values, add.names=add.names)
            MarkerList(m, ...)
            
        }
)
#' Create a MarkerList from the expression matrix of an \code{\linkS4class{ExpressionSet}}
#' object.
#' 
#' This is a shortcut for \code{MarkerList(exprs(object), ...)}.
setMethod('MarkerList', 'ExpressionSet', 
        function(object, ...){
            m <- MarkerList(exprs(object), ...)
            # pass on annotations
            annotation(m) <- annotation(object)
            m
        }
)

